# Лабораторна робота №2. Криптографія

## Опис роботи чат-програми

1. На комп'ютері запускається сервер за допомогою `server.py` та будь-яка кількість клієнтів за допомогою `client.py`. Це можна зробити швидко за допомогою доданого batch-файла `launch.bat`.
2. Сервер генерує пару RSA ключів: публічний, для шифрування повідомлень клієнтами, та приватний, для дешифрування повідомлень сервером.
3. Кожен з клієнтів під'єднується до сервера і отримує публічний ключ сервера, а сам генерує пару ключів так само, і повідомляє свій публічний ключ серверу. Сервер записує та зберігає всі публічні ключі кожного клієнта.
4. Коли клієнт хоче надіслати повідомлення, він зашифровує його публічним ключем сервера та надсилає йому.
5. Сервер отримує зашифроване повідомлення клієнта і дешифрує його своїм приватним ключем. Далі задача сервера - це зашифрувати це повідомлення публічним ключем кожного з клієнтів і надіслати їм.
6. Але перед цим сервер рахує хеш повідомлення і готує для надіслання разом з зашифрованим повідомленням. Після того, як сервер це зробив, кожен клієнт отримує загальнодоступний хеш та унікальне повідомлення, зашифроване його власним публічним ключем.
7. В результаті дешифрування кожним з клієнтів повідомлення його власним приватним ключем, всі мають отримати одне й те саме першопочаткове повідомлення. Також після дешифрування клієнтом знову рахується хеш повідомлення, і якщо він не співпадає з надісланим, викликається попередження.

## Опис роботи алгоритмів

### Генерування ключів

Генерування пари з приватного та публічного ключа виконується згідно з загальноприйнятим алгоритмом RSA. Функція генерування приймає як аргумент параметр `length`, який визначає, наскільки довгими мають бути ключі (тобто наскільки великими мають бути числа).

1. Спочатку навмання обирається два великих простих числа - p та q. Знаючи, що кожне просте число може бути записано як 6k +- 1, я обираю рандомне k з діапазону [2^(length - 1); 2^length] та перевіряю 6k - 1 та 6k + 1 за допомогою функції `is_prime()` на простоту. Повторюю процес, допоки не знайдеться просте число.
2. Рахується n, який є добутком p та q.
3. Рахується phi від n за функцією Ейлера, але через те, що ми вже знаємо, що n складається з двох простих чисел, можемо просто порахувати його за скороченою формулою: (p - 1) (q - 1)
4. Далі обирається число e, яке буде слугувати основою публічного ключа. Це може бути будь-яке непарне число, яке взаємопросте з phi.
5. Тепер рахується основа приватного ключа - число d. Щоб знайти його, треба порахувати обернений елемент до e за модулем phi.
6. Готово. Публічний ключ це (e, n), а приватний - (d, n).

### Шифрування

Шифрування виконується строго так, як написано у лекції, тому повідомлення не може містити жодних символів окрім літер англійського алфавіту. На вхід функція шифрування отримує повідомлення та публічний ключ, яким і шифрує повідомлення.

1. Спочатку функція конвертує англійський текст в цифровий формат та розбиває його на блоки. Тобто літері A відповідає число 00, літері B - число 01 і так далі. Через те, що ми працюємо лише з англійськими символами, у нас чітко визначений діапазон можливих чисел - від 00 до 25. Тому ми можемо порахувати оптимальну довжину для кожного блока повідомлення. Для цього ми беремо найбільше додатнє число 2N, таке, що 2525...25 із 2N чисел не перевищує n (спільна частина публічного та приватного ключа). В кожному блоці має бути рівно 2N цифр. Іноді, втім, виникає ситуація, коли повідомлення не вдається розділити на рівні за довжиною блоки. Тоді до останнього з них додається стільки фіктивних символів, скільки треба, щоб блок став потрібної довжини. В нашому випадку за фіктивний символ слугує 99, тому що жодному символу з англійського алфавіту не відповідає число 99.
2. Тепер саме шифрування. Все доволі просто: кожен числовий блок M перетворюється на зашифрований блок C за допомогою функції C = M^e (mod n). Хоча функція проста, обчислення при великих числах можуть бути дуже складними, тому тут використовується алгоритм швидкого піднесення до степеня за модулем.
3. Коли все зроблено, функція розділяє кожний зашифрований блок пробілом і повертає результат як текст. Якщо отримувач має свій приватний ключ, він зможе легко дешифрувати це повідомлення.

### Дешифрування

Функція decrypt виконує розшифрування повідомлень, зашифрованих алгоритмом RSA. Вона приймає:

Приватний ключ у форматі (d, n, p, q), де:
d - секретний показник
n - модуль
p, q - прості числа (використовуються для оптимізації)
Зашифрований текст у вигляді рядка чисел, розділених пробілами
Процес роботи:

Виділяє компоненти d та n з ключа
Розбиває вхідний рядок на окремі числові блоки
Для кожного блока обчислює: decrypted_num = pow(num, d, n)
Конвертує отримані числа назад у символи ASCII
Об'єднує символи в результуючий рядок
Обробка помилок:

При невірних вхідних даних додає спецсимвол (�)
Логує помилки дешифрування

### Підрахунок хешу повідомлення

Функція calculate_hash обчислює SHA-256 хеш повідомлення для перевірки цілісності.

Особливості:

Приймає текстовий рядок будь-якої довжини
Повертає хеш у HEX-форматі
Використовується для:
Перевірки незмінності повідомлень
Виявлення помилок передачі
Запобігання MITM-атакам
Технічні деталі:

Використовує стандартний алгоритм SHA-256
Кодування UTF-8 для текстових даних
Фіксована довжина виводу (64 символи)

## Розподіл роботи
### Омелянчук Кирило
- Весь функціонал у файлах server.py та client.py
- Генерування ключів включно зі всіма функціями у utils.py крім `calculate_hash()`
- Шифрування повідомлень. Функція `encrypt()`

### Миколайчук Назар
- Дешифрування повідомлень. Функція `decrypt()`
- Підрахунок хешу повідомлень. Функція `calculate_hash()`
